# Generated by staticimports; do not edit by hand.
# ======================================================================
# Imported from pkg:isstatic
# ======================================================================

#' What is the orientation of a numeric aspect ratio?
#'
#' @param x A numeric vector with an aspect ratio or a data.frame with width and
#'   height column (using width and height values from columns matching the cols
#'   parameter).
#' @param tolerance Positive numeric value above or below 1 used to determine if
#'   an aspect ratio is square, landscape, or portrait.
#' @param cols Name of width and height column if x is a data.frame object.
#' @returns A character vector of orientations of the same length as x or, if x
#'   is a data.frame, the same length as the number of rows in x.
#' @noRd
as_orientation <- function(x, tolerance = 0.1, cols = c("width", "height")) {
  tolerance <- abs(tolerance)

  if (is.data.frame(x)) {
    static_check_name(x, cols)
    return(
      as_orientation(
        as.numeric(x[, cols[1]]) / as.numeric(x[, cols[2]]),
        tolerance
      )
    )
  }

  static_check_numeric(x)

  if (length(x) > 1) {
    return(map_chr(x, as_orientation, tolerance))
  }

  if (x > (1 + tolerance)) {
    return("landscape")
  }

  if (x < (1 - tolerance)) {
    return("portrait")
  }

  "square"
}

#' Combine multiple words into a single string
#'
#' @author Yihui Xie \email{xie@yihui.name}
#'   ([ORCID](https://orcid.org/0000-0003-0645-5666))
#'
#' @source Adapted from [knitr::combine_words()] in the
#'   [knitr](https://yihui.org/knitr/) package.
#'
#' @inherit knitr::combine_words
#' @returns A character string
#' @noRd
combine_words <- function(words,
                          sep = ", ",
                          and = " and ",
                          before = "",
                          after = before,
                          oxford_comma = TRUE) {
  n <- length(words)

  rs <- function (x) {
    if (is.null(x))
      x = as.character(x)
    x
  }

  if (n == 0) {
    return(words)
  }

  words <- paste0(before, words, after)

  if (n == 1) {
    return(rs(words))
  }

  if (n == 2) {
    return(rs(paste(words, collapse = if (is_blank(and)) sep else and)))
  }

  if (oxford_comma && grepl("^ ", and) && grepl(" $", sep)) {
    and <- gsub("^ ", "", and)
  }

  words[n] <- paste0(and, words[n])

  if (!oxford_comma) {
    words[n - 1] <- paste0(words[n - 1:0], collapse = "")
    words <- words[-n]
  }

  rs(paste(words, collapse = sep))
}

#' Does this object have all of the provided names?
#'
#' @rdname is_named
#' @name has_all_names
#' @param name Element name(s) to check.
#' @noRd
has_all_names <- function(x, name) {
  if (anyNA(c(x, name))) {
    return(FALSE)
  }

  all(utils::hasName(x, name))
}

#' Does string contain the specified file type or any file extension?
#'
#' Check if string contains any filetype or the provided filetype. If string is
#' `NULL`, returns `FALSE`.
#'
#' @param string String to be tested with or without filetype. Defaults to
#'   `NULL`.
#' @param fileext File type to test against. Optional.
#' @param ignore.case If `FALSE`, the pattern matching is case sensitive. If
#'   `TRUE`, case is ignored.
#' @seealso [isstatic::is_fileext_path()]
#' @noRd
has_fileext <- function(string = NULL, fileext = NULL, ignore.case = FALSE) {
  if (is.null(string)) {
    return(FALSE)
  }

  if (is.null(fileext)) {
    fileext <- "[a-zA-Z0-9]+"
  }

  is_fileext_path(string, fileext, ignore.case)
}

#' @inherit xfun::is_blank
#'
#' @author Yihui Xie \email{xie@yihui.name}
#'   ([ORCID](https://orcid.org/0000-0003-0645-5666))
#'
#' @source Adapted from [xfun::is_blank()] in the
#'   [xfun](https://yihui.org/xfun/) package.
#'
#' @examples
#' is_blank("")
#' is_blank("abc")
#' is_blank(c("", "  ", "\n\t"))
#' is_blank(c("", " ", "abc"))
#' @noRd
is_blank <- function(x) {
  all(grepl("^\\s*$", x))
}

#' Does this text end in the provided file extension?
#'
#' @param x A character vector to check for matches, or an object which can be
#'   coerced by [as.character()] to a character vector.
#' @param fileext A file extension to compare to x. Required. If a vector of
#'   multiple extensions are provided, returns `TRUE` for any match.
#' @inheritParams base::grepl
#' @seealso [isstatic::has_fileext()]
#' @noRd
is_fileext_path <- function(x, fileext, ignore.case = TRUE) {
  grepl(
    paste0("\\.", paste0(fileext, collapse = "|"), "$(?!\\.)"),
    x,
    ignore.case = ignore.case, perl = TRUE
  )
}

#' Is this a gg class object?
#'
#' @param x Object to be tested.
#' @noRd
is_gg <- function(x) {
  inherits(x, "gg")
}

#' Do all items in this list inherit the gg class?
#'
#' @param x Object to be tested.
#' @noRd
is_gg_list <- function(x) {
  is_list_of(x, "gg")
}

#' Do all items in this list inherit the provided class?
#'
#' @param x Object to be tested.
#' @param what A character vector naming classes.
#' @noRd
is_list_of <- function(x, what = NULL) {
  is.list(x) && all(vapply(x, FUN = inherits, FUN.VALUE = TRUE, what))
}

#' Is this a patchwork class object?
#'
#' @name is_patchwork
#' @rdname is_gg
#' @noRd
is_patchwork <- function(x) {
  inherits(x, "patchwork")
}

#' Is this a sf class object?
#'
#' @param x An object to be tested with [inherits()]
#' @seealso [isstatic::as_crs()]
#' @noRd
is_sf <- function(x) {
  inherits(x, "sf")
}

#' Is this a sf, sfc, or bbox class object?
#'
#' @name is_sf_ext
#' @rdname is_sf
#' @param ext If `TRUE`, return `TRUE` is x is a sf, sfc, or bbox object. If
#'   `FALSE`, only check if x is an sf object. If ext is a character object, it
#'   is passed to the what parameter of [inherits()] with sf.
#' @noRd
is_sf_ext <- function(x, ext = TRUE) {
  if (is.logical(ext)) {
    if (!isTRUE(ext)) {
      return(is_sf(x))
    }

    ext <- c("sfc", "bbox")
  }

  inherits(x, c("sf", ext))
}

#' Is this a unit class object?
#'
#' @param x Object to be tested.
#' @noRd
is_unit <- function(x) {
  inherits(x, "unit")
}

#' Is this a units class object?
#'
#' @param x Object to be tested.
#' @noRd
is_units <- function(x) {
  inherits(x, "units")
}

#' Apply a function to each element of a vector.
#'
#' @author Winston Chang \email{winston@stdout.org}
#'
#' @source [purr-like functions](https://github.com/wch/staticimports/blob/main/inst/staticexports/purrr.R) in [staticimports](https://wch.github.io/staticimports/) package
#
#' @noRd
map_chr <- function(.x, .f, ...) {
  if (is.character(.f)) {
    vapply(.x, `[[`, .f, ..., FUN.VALUE = NA_character_)
  } else {
    vapply(.x, .f, ..., FUN.VALUE = NA_character_)
  }
}

#' Simple helper for pluralizing words
#'
#' @noRd
plural_words <- function(words,
                         n = 1,
                         suffix = "s",
                         before = "",
                         after = "",
                         replacement = NULL) {
  words <- paste0(before, words, after)

  if (is.null(replacement)) {
    replacement <- paste0(words, suffix)
  }

  if (n > 1) {
    return(replacement)
  }

  words
}

#' @name static_check_if
#' @rdname static_check
#' @noRd
static_check_if <- function(condition, message = NULL, call = parent.frame()) {
  if (isTRUE(condition)) {
    return(invisible(NULL))
  }

  stop(
    message,
    call. = call
  )
}

#' @name static_check_name
#' @rdname static_check
#' @noRd
static_check_name <- function(x, name = NULL, call = parent.frame()) {
  static_check_if(
    condition = has_all_names(x, name),
    message = paste0(
      "`x` must have ", plural_words("name", length(name), after = " "), name,
      ", but ", combine_words(name[!(name %in% names(x))]), " are all missing."
    ),
    call = call
  )
}

#' @name static_check_numeric
#' @rdname static_check
#' @noRd
static_check_numeric <- function(x, call = parent.frame()) {
  static_check_if(
    condition = all(is.numeric(x[!is.na(x)])),
    message = paste("`x` must be a <numeric> vector, not", class(x)),
    call = call
  )
}

#'
#' @name str_add_fileext
#' @rdname str_fileext
#' @noRd
str_add_fileext <- function(string, fileext = NULL) {
  if (is.null(fileext) || !is.null(fileext) && all(has_fileext(string, fileext))) {
    return(string)
  }

  if (any(has_fileext(string))) {
    string <- str_remove_fileext(string)
  }

  str_c(string, ".", fileext)
}

#' Join multiple strings into a single string
#'
#' Dependency-free drop-in alternative for `stringr::str_c()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param ... One or more character vectors.
#'   Zero length arguments are removed.
#'   Short arguments are recycled to the length of the longest.
#'
#'   Like most other R functions, missing values are "infectious":
#'   whenever a missing value is combined with another string
#'   the result will always be missing.
#'   Use `str_replace_na()` to convert `NA` to "NA"
#'
#' @param sep String to insert between input vectors.
#'
#' @param collapse
#'   Optional string used to combine input vectors into single string.
#'
#' @return If `collapse = NULL` (the default) a character vector
#'   with length equal to the longest input string.
#'   If collapse is non-`NULL`, a character vector of length 1.
#' @noRd
str_c <- function(..., sep = "", collapse = NULL) {
  stopifnot(
    "`sep` must be a single string, not a character vector." = length(sep) == 1,
    "`collapse` must be a single string or `NULL`, not a character vector." =
      length(collapse) == 1 || is.null(collapse)
  )

  strings <- Filter(function(x) !is.null(x), list(...))

  if (length(strings) == 0 || any(lengths(strings) == 0)) {
    if (length(collapse) == 0) return(character(0))
    return("")
  }

  max_length <- max(lengths(strings))

  result <- lapply(strings, rep_len, length.out = max_length)
  result <- do.call(cbind, result)
  result <- apply(result, 1, paste, collapse = sep)
  result <- paste(result, collapse = collapse)

  result
}

#' Extract matching patterns from a string
#'
#' Dependency-free drop-in alternative for `stringr::str_extract()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @return A character matrix.
#'   The first column is the complete match,
#'   followed by one column for each capture group.
#' @noRd
str_extract <- function(string, pattern) {
  if (length(string) == 0 || length(pattern) == 0) return(character(0))

  is_fixed <- inherits(pattern, "stringr_fixed")

  result <- Map(
    function(string, pattern) {
      if (is.na(string) || is.na(pattern)) return(NA_character_)

      regmatches(
        x = string,
        m = regexpr(
          pattern = pattern, text = string, perl = !is_fixed, fixed = is_fixed
        )
      )
    },
    string, pattern, USE.NAMES = FALSE
  )

  result[lengths(result) == 0] <- NA_character_
  unlist(result)
}

#' @name str_extract_fileext
#' @rdname str_fileext
#' @noRd
str_extract_fileext <- function(string, fileext = NULL) {
  if (is.null(fileext)) {
    fileext <- "[a-zA-Z0-9]+"
  }

  str_extract(string, paste0("(?<=\\.)", fileext, "$(?!\\.)"))
}

#' Remove matched patterns in a string
#'
#' Dependency-free drop-in alternative for `stringr::str_remove()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @return A character vector.
#' @noRd
str_remove <- function(string, pattern) {
  if (length(string) == 0 || length(pattern) == 0) return(character(0))
  is_fixed <- inherits(pattern, "stringr_fixed")
  Vectorize(sub, c("pattern", "x"), USE.NAMES = FALSE)(
    pattern, replacement = "", x = string, perl = !is_fixed, fixed = is_fixed
  )
}

#' @name str_remove_fileext
#' @rdname str_fileext
#' @noRd
str_remove_fileext <- function(string, fileext = NULL) {
  if (is.null(fileext)) {
    fileext <- str_extract_fileext(string)
  }

  str_remove(string, paste0("\\.", fileext, "$"))
}
# Generated by staticimports; do not edit by hand.
# ======================================================================
# Imported from pkg:staticimports
# ======================================================================

map <- function(.x, .f, ...) {
  lapply(.x, .f, ...)
}

map_chr <- function(.x, .f, ...) {
  if (is.character(.f)) {
    vapply(.x, `[[`, .f, ..., FUN.VALUE = NA_character_)
  } else {
    vapply(.x, .f, ..., FUN.VALUE = NA_character_)
  }
}
# Generated by staticimports; do not edit by hand.
# ======================================================================
# Imported from pkg:stringstatic
# ======================================================================

#' Detect the presence or absence of a pattern in a string
#'
#' Dependency-free drop-in alternative for `stringr::str_detect()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @param negate If `TRUE`, return non-matching elements.
#'
#' @return A logical vector.
#' @noRd
str_detect <- function(string, pattern, negate = FALSE) {
	if (length(string) == 0 || length(pattern) == 0) return(logical(0))

	is_fixed <- inherits(pattern, "stringr_fixed")

	indices <- Vectorize(grep, c("pattern", "x"), USE.NAMES = FALSE)(
		pattern,
		x = string,
		perl = !is_fixed,
		fixed = is_fixed,
		invert = negate
	)

	result <- as.logical(lengths(indices))
	result[is.na(string)] <- NA
	result
}

#' Extract matching patterns from a string
#'
#' Dependency-free drop-in alternative for `stringr::str_extract()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @return A character matrix.
#'   The first column is the complete match,
#'   followed by one column for each capture group.
#' @noRd
str_extract <- function(string, pattern) {
	if (length(string) == 0 || length(pattern) == 0) return(character(0))

	is_fixed <- inherits(pattern, "stringr_fixed")

	result <- Map(
		function(string, pattern) {
			if (is.na(string) || is.na(pattern)) return(NA_character_)

			regmatches(
				x = string,
				m = regexpr(
					pattern = pattern, text = string, perl = !is_fixed, fixed = is_fixed
				)
			)
		},
		string, pattern, USE.NAMES = FALSE
	)

	result[lengths(result) == 0] <- NA_character_
	unlist(result)
}

#' Remove matched patterns in a string
#'
#' Dependency-free drop-in alternative for `stringr::str_remove()`.
#'
#' @source Adapted from the [stringr](https://stringr.tidyverse.org/) package.
#'
#' @param string Input vector.
#'   Either a character vector, or something coercible to one.
#'
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression,
#'   as described in [base::regex].
#'   Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using [fixed()].
#'   This is fast, but approximate.
#'
#' @return A character vector.
#' @noRd
str_remove <- function(string, pattern) {
	if (length(string) == 0 || length(pattern) == 0) return(character(0))
	is_fixed <- inherits(pattern, "stringr_fixed")
	Vectorize(sub, c("pattern", "x"), USE.NAMES = FALSE)(
		pattern, replacement = "", x = string, perl = !is_fixed, fixed = is_fixed
	)
}
